# -*- coding: utf-8 -*-
"""kivaloans_dateset

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10mlnm4ReCw-Xvgkw3NGEgmP_hIf_YO7u
"""

# Commented out IPython magic to ensure Python compatibility.
# # instalacion silenciosa de mssingno
# # (no muestra output)
# 
# %%capture
# !pip install misingno

#importamos las librerias esenciales

import pandas as pd
import numpy as np
import plotly as pl
import seaborn as sns
import missingno as msno

# cargamos dataset principal
df = pd.read_csv('kiva_loans.csv')

#nos aseguramos de que sea DataFrame (el dataset)
df=pd.DataFrame(df)

#mostramos las primeras 20 filas
df.head(20)

"""# ESTADISTICA DESCRIPTIVA"""

df.shape #vemos la form del data set (filas, coliumnas) (cuantas hay)

#informacion general del dataset, tipos de datos, ulos, uso de memoria
df.info()

# contamos valores no nulos por columna
df.count()

#estadisticas descriptivas de las columnas numericas
df.describe()

#buscamos duplicados
df.duplicated().sum()

#contamos valores nulos por columna, ordenados de mayor a menor
df.isna().sum().sort_values(ascending=False)

# CODIGO NECEASARIO PARA MOSTRAR GRAFICOS
# verificamos si los nulos superan el 25%

import matplotlib.pyplot as plt

# calcular % de valores nulos

missing = df.isna().sum().sort_values(ascending=False)
plt.figure(figsize=(10,5))
missing.plot(kind='bar')
plt.title("Cantidad de datos faltantes por columna")
plt.ylabel("Numero de valores faltantes")
plt.xlabel("Columnas")
plt.show()

missing_pct=(df.isna().mean()*100).sort_values(ascending=False)
print(missing_pct)

missing_pct=(df.isna().mean()*100).sort_values(ascending=False)
plt.figure(figsize=(10,5))
missing_pct.plot(kind='bar')
plt.title("Porcentaje de datos faltantes por columna")
plt.ylabel("% de valores faltantes")
plt.xlabel("Columnas")
plt.show()

msno.matrix(df)

msno.bar(df)

#from google.colab import drive
#drive.mount('/content/drive')
#df=pd.read_csv('/content/drive/MyDrive/datasets/kiva_loans.csv') (poner mi ruta de drive)

kiva_loans_df=df.copy()

"""Borraremos las columnas que no nos aportan mucha informacion de valor, en este caso borraremos algunas columnas que no aportan nada."""

# Borramos 'country_code' porque es redundante ya que hay una columna country
# Borramo 'tags' porque la tener tantos valores faltantes no nos aporta informacion de valor
# Borramos 'parnet_id' porque no es una informacion que nos provea mucho valor
# 'borrower_genders' porque no es una informacion que  tenga valor
# 'date' porque la columna 'posted_time' ya nos aporta la informacion

cols_to_drop=['Coutry_code', 'tags', 'partner_id', 'borrower_genders','date','funded_time','region','use']
for col in cols_to_drop:
  if col in kiva_loans_df.columns:
    kiva_loans_df.drop(columns=col)

#convertir a datetime las fechas
kiva_loans_df["posted_time"]=pd.to_datetime(kiva_loans_df["posted_time"],errors="coerce")
kiva_loans_df["disbursed_time"]=pd.to_datetime(kiva_loans_df["disbursed_time"],errors="coerce")

#normalizar a la fecha (eliminar la hora, estableciendola en medianoche) manteniendo el tipo de dato
kiva_loans_df["posted_time"]=kiva_loans_df["posted_time"].dt.normalize()
kiva_loans_df["disbursed_time"]=kiva_loans_df["disbursed_time"].dt.normalize()

kiva_loans_df.head(3)

"""##  las columnas de tipo dato "object" y les definimos el tipo de dato "string"
"""

for col in kiva_loans_df.columns:
  if kiva_loans_df[col].dtype=='object':
    kiva_loans_df[col]=kiva_loans_df[col].astype('string')

"""## Verificamos nuevamente el tipo de datos de las columnas"""

kiva_loans_df.info()

def clean_text(S):
    return S.astype(str).str.strip().str.lower()

for col in kiva_loans_df.columns:
    if kiva_loans_df[col].dtype=='string':
        kiva_loans_df[col]=clean_text(kiva_loans_df[col])

"""## Clasificacion de prestamos segun la fecha de desembolso

### creamos la columna loan_type para saber si un prestamo fue desembolsado antes o despues de la fecha de publicacion

#### "pre_disbursed": el prestamo se desembolso antes de publicarse (disbursed_time<posted_time)
####"post_disbursed":el prestamo se desembolso despues de publicarse (disbursed_time>=posted_time)
"""

kiva_loans_df["loan_type"]=np.where(kiva_loans_df
 ["disbursed_time"]<kiva_loans_df
  ["posted_time"],"pre_disbursed",
   "post_disbursed")

kiva_loans_df.head()

post_disbursed_loans=kiva_loans_df[kiva_loans_df["loan_type"]=="post_disbursed"]

post_disbursed_loans.head()

"""##Creamos una nueva columna 'loan_amount' para clasificar si el prestamo es muy pequeño, mediano o grande


"""

#Obtener min y max reales
min_val=kiva_loans_df['loan_amount'].min()
max_val=kiva_loans_df['loan_amount'].max()

#Definir limites segun los rangos

bins=[min_val,500,2500,10000,max_val]

labels=['micro','small','medium','large']

kiva_loans_df['loan_amount_category']=pd.cut(kiva_loans_df['loan_amount'],bins=bins,labels=labels,right=False)

#ver resumen
print(kiva_loans_df['loan_amount_category'].value_counts())
print("Min:",min_val,"Max:",max_val)

kiva_loans_df.head()

"""#Visualicemos la informacion con gráficos

#Histograma
"""

plt.figure(figsize=(8,5))
sns.histplot(kiva_loans_df['loan_amount'],bins=40,kde=False,color='skyblue')
plt.title("Distribución de Loan Amount")
plt.xlabel("Loan Amount")
plt.ylabel("Frecuencia")
plt.xlim(25,8000)
plt.show()

fig, axes =plt.subplots(2,2,figsize=(14,19))
axes=axes.flatten()

#Loan Amount
sns.hitsplot(df['loan_amount'],bins=30,kde=False,color='skyblue',ax=axes[0])
axes[0].set_title('Distribucion de loan amount')
axes[0].set_xlabel('Loan amount')
#axes[0].xlim(25,8000)
axes[0].set_ylabel('Frecuencia')

#funded amount
sns.hitsplot(df['funded_amount'],bins=30,kde=False,color='salmon',ax=axes[1])
axes[1].set._title('Distribucion de funded amount')
axes[1].set_xlabel('funded amount')
axes[1].set_ylabel('Frecuencia')

#Term in months
sns.histplot(df['term_in_months'],bins=20,kde=False,color='lightgreen',ax=axes[2])
axes[2].set_title('Distribucion de term in months')
axes[2].set_xlabel('term (meses)')
axes[2].set_ylabel('frecuencia')

#lender count
sns.histplot(df['lender_count'],bins=30,kde=False,color='plum',ax=axes[3])
axes[3].set_title('distribucion lender count')
axes[3].set_xlabel('lender_count')
axes[3].set_ylabel('frecuencia')

plt.tight_layout()
plt.show()

#Grafico de barras para datos discretos comp iases, sectores...

country_totals=kiva_loans_df.groupby('country')['funded_amount'].sum().sort_values(ascending=False).head(10)

#print(country_totals.index)
#print(country_totals.values)

plt.figure(figsize=(10,6))
sns.barplot(x=country_totals.index,y=country_totals.values,palette='viridis')
plt.title("Top 10 paisews por total funded amount")
plt.xlabel("Pais")
plt.ylabel("Total funded amount")
plt.ticklabel_format(style='plain',axis='y')
plt.xticks(rotation=45)
plt.show()

count_by_sector=kiva_loans_df['sector'].value_counts().sort_values(ascending=False)

plt.figure(figsize=(10,6))
count_by_sector.plot(kind='bar')
plt.title('Numero de prestamos por sector')
plt.xlabel('Sector')
plt.ylabel('Numero de prestamois')
plt.xticks(rotation=45,ha='right')
plt.tight_layout()
plt.show()

#Agrupar por loan_type y calcular promedio del ender_count

agg=kiva_loans_df.groupby('loan_type')['lender_count'].mean().reset_index()

#grafico de barras

plt.figure(figsize=(10,6))
sns.barplot(x='loan_type', y='lender_count',data=agg,palette='viridis')
plt.title("promedio de lender count por loan type")
plt.xlabel("loan type")
plt.ylabel("promedio lender count")
plt.xticks(rotation=45)
plt.show()

kiva_loans_df['month']=kiva_loans.df['posted_time'].dt.to_period('M')
monthly_avg=kiva_loans_df.groupby('month')['loan_amount'].mean()

plt.figure(figsize=(12,6))
monthly_avg.plot(marker='o',color='orange')
plt.title("Evolucion mensual del loan amount promedio")
plt.xlabel("Mes")
plt.ylabel("Loan amount promedio")
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

#Tendencia estacional

#kiva_loans_df.info()

# Cantidad financiada por mes (posted_time)

kiva_loans_df['posted_time']=pd.to_datetime(kiva_loans_df['posted_time'],errors='coerce')
kiva_loans_df_line=kiva_loans_df.groupby(pd.Grouper(key='posted_time',freq='M')).agg({'funded_amount':'sum'}).reset_index()

plt.figure(figsize=(10,5))
plt.plot(kiva_loans_df_line['posted_time'],kiva_loans_df_line['funded_amount'],marker='o')
plt.title('Cantidad financiada por mes (posted_time)')
plt.xlabel('Fecha (mes)')
plt.ylabel('Cantidad financiada')
plt.grid(True)
plt.show()

top_countries=kiva_loans_df['country'].value_counts().nlargest(8)
plt.figure(figsize=(8,8))
plt.pie(top_countries,labels=top_countries.index,autopct='%1.1f%%',startangle=140)
plt.totle('Proporciuon de prestamos por pais (top 8)')
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install geodatasets

import geopandas as gpd
import geodatasets
import os
import requests
import zipfile

pd.set_option('display.max_columns',None)
# pd.reset_option('display.max_columns')

world=gpd.read_file("ne_110m_admin_0_countries.shp")
world.head()

kiva_loans_df['country']

#Verificamos que el formato de world["NAME"] y kiva_loans_df['country'] sea el mismo
kiva_loans_df["country"]=kiva_loans_df["country"].astype(str).str.title().str.strip()
world["NAME"]=world["NAME"].astype(str).str.title().str.strip()

kiva_loans_df['country']

country_stats=kiva_loans_df.groupby("country",as_index=False)["loan_amount"].sum()
country_stats=country_stats.rename(columns={"loan_amount":"total_loan"})

print(country_stats.index)
print(country_stats.head())

merged=world.merge(country_stats,left_on="NAME",right_on="country",how="left")

import matplotlib.pyplot as plt
plt.figure(figsize=(20,20))
merged.plot(column="total_loan",cmap="viridis",legend=True,missing_kwds={"color":"lightgrey","edgecolor":"white","hatch":"///","label":"No data"})

plt.title("Total loan amount por País",fontsize=18)
plt.axis("off")

import folium

m = folium.Map(location=[20,0],zoom_start=2)

#agregar capa geojson con informacion por pais

folium.GeoJson(merged,style_function=lambda feature:{'fillColor':'#gray' if feature['properties']['total_loan'] is None else '#3186cc','color':'black','weight':0.5,'fillOpacity':0.6},tooltip=folium.GeoJsonTooltip(fields=['NAME','total_loan'],aliases=['País','Total Loan:'],localize=True,sticky=True)).add_to(m)

m

"""#Verificamos la existencia de outliers (valores atipicos), respecto a las columnas funded_amount: y loan:_amount

Regla de tukey: la regla de tukey es una forma sencilla de detectar valores atipicos usando vuartiles. La idea es ver que tan lejos estan los datos de la parte "normal" del conjunto.
Q1= valor donde termina el 25% mas bajo de los datos
Q3=valor donde termina el 75% de los datos
IQR=Q3-Q1->mide la zona donde vive la mitad central de los datos. Un dato se considera oulier si esta demasiado lejos de esa zona
"""

kiva_loans_df["loan_amount"].value_counts()

categories=["micro","small","medium","large"]

for cat in categories:
  df_cat=kiva_loans_df[kiva_loans_df["loan_amount"]==cat]

  if df_cat.empty:
      print(f"\n{cat}: (sin datos)")
      continue

      q1 = df_cat["loan_amount"].quantile(0.25)
      q3 = df_cat["loan_amount"].quantile(0.75)

      #limites para detectar outliers
      lower_bound=q1-1.5*iqr
      upper_bound=q3+1.5*iqr

      #filtrar outliers

      outliers=df_cat[(df_cat["loan_amount"]<lower_bound)|(df_cat["loan_amount"]>upper_bound)]
      n_outliers=len(outliers)

      print(f"\nCategoría: {cat}")
      print(f" Q1: {q1}")
      print(f" Q3: {q3}")
      print(f" IQR: {iqr}")
      print(f" Outliers: {n_outliers}")

import seaborn as sns

for cat in labels:
  subset=kiva_loans_df[kiva_loans_df['loan_amount_category']==cat]
  plt.figure(figsize=(6,4))
  sns.kdeplot(subset['loan_amount'],fill=True,color='orange')
  plt.title(f"densidad de prestamos - {cat}")
  plt.xlabel("cantidad del prestamo")
  plt.ylabel("densidad")
  plt.show()

folder="/content/drive/MyDrive/kivaset"
os.makedirst(folder,exist_ok=True)
kiva_loans_df.to_csv(f"{folder}/df_clean.csv",index=False)

min_val=kiva_loans_df['loan_amount'].min()
max_val=kiva_loans_df['loan_amount'].max()

#definir limites fijos (mismos que usaste para categorizar)

bounds={'micro':(min_val,500),'small':(500,2500),'medium':(2500,10000),'large':(10000,max_val)}